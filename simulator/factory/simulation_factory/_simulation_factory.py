from enum import Enum

from numpy import array, concatenate as cat

from external.qspace_sampler.sampling import multishell

from .handlers import SimulationHandler
from .parameters import (
    AcquisitionProfile,
    ArtifactModel,
    GradientProfile,
    StejskalTannerType,
    TensorValuedByEigsType,
    TensorValuedByParamsType,
    TensorValuedByTensorType,
)


class SimulationFactory:
    """Factory class used to generate Fiberfox configuration components"""

    class CompartmentType(Enum):
        """Compartments available for simulation in Fiberfox"""

        INTRA_AXONAL = "1"
        INTER_AXONAL = "2"
        EXTRA_AXONAL_1 = "3"
        EXTRA_AXONAL_2 = "4"

    class AcquisitionType(Enum):
        """
        Acquisition types available in Fiberfox. Can be either a basic
        Stejskal-Tanner linear acquisition or a tensor-valued acquisition.
        """

        STEJSKAL_TANNER = StejskalTannerType
        TENSOR_VALUED_BY_TENSOR = TensorValuedByTensorType
        TENSOR_VALUED_BY_EIGS = TensorValuedByEigsType
        TENSOR_VALUED_BY_PARAMS = TensorValuedByParamsType

    class NoiseType(Enum):
        """
        Noise types available in fiberfox. This only correspond to whole image
        noises, acquisition artifacts are described by the artifact methods
        available in the factory
        """

        COMPLEX_GAUSSIAN = "gaussian"
        RICIAN = "rician"

    @staticmethod
    def get_simulation_handler(geometry_handler, compartments=None):
        """
        Returns the handler in which all the components must be put in order to
        generate the xml configuration file for Fiberfox.

        Parameters
        ----------
        geometry_handler : GeometryHandler
            The handler used to generate the geometry for the simulation
        compartments : list, optional
            A list of compartment models generated by the factory to
            preload in the handler

        Returns
        -------
        SimulationHandler
            A simulation handler in which to put all the components to simulate

        """
        return SimulationHandler(
            geometry_handler.get_resolution(),
            geometry_handler.get_spacing(),
            compartments,
        )

    @staticmethod
    def generate_acquisition_profile(
        echo_time,
        repetition_time,
        n_channels,
        dwell_time=1,
        partial_fourier=1,
        signal_scale=4000,
        reverse_phase=False,
        inhomogen_time=50,
        axon_radius=0,
        inversion_time=0,
        echo_train_length=8,
    ):
        """
        Generate the acquisition profile component used to
        simulate the acquisition sequence

        Parameters
        ----------
        echo_time : int
            TE of the sequence (milliseconds)
        repetition_time : int
            TR of the sequence (milliseconds)
        n_channels : int
            Number of coils to simulate
        dwell_time : int, optional
            Time to acquire a sample of the k-space (milliseconds), default : 1
        partial_fourier : float, optional
            Partial fourier ratio, default : 1
        signal_scale : int, optional
            Value by which the output signal is raised, default : 100
        reverse_phase : bool, optional
            Either to acquire AP or PA, default : False
        inhomogen_time : int, optional
            Gradient inhomogeneity time (milliseconds), default : 50
        axon_radius : float, optional
            Radius of the axons of the simulated fiber medium, 0 for
            auto-determination by Fiberfox, default : 0
        inversion_time : int, optional
            Tinv of the sequence (milliseconds)
        echo_train_length : int, optional
            Number of echoes per datapoint

        Returns
        -------
        AcquisitionProfile
            An acquisition profile component

        """
        return (
            AcquisitionProfile(None, None)
            .set_echo(echo_time)
            .set_repetition(repetition_time)
            .set_n_coils(n_channels)
            .set_dwell(dwell_time)
            .set_partial_fourier(partial_fourier)
            .set_scale(signal_scale)
            .set_reverse_phase(reverse_phase)
            .set_inhomogen_time(inhomogen_time)
            .set_axon_radius(axon_radius)
            .set_inversion(inversion_time)
            .set_train_length(echo_train_length)
        )

    @staticmethod
    def generate_gradient_vectors(points_per_shell, max_iter=1000):
        """
        Generate an optimally distributed list of gradient
        vectors on one or more shell

        Parameters
        ----------
        points_per_shell : list(int)
            List of gradient directions per shell
        max_iter : int, optional
            Maximum iterations available for the optimisation algorithm

        Returns
        -------
        list(list(float))
            A list of gradient vectors

        """
        weights = multishell.compute_weights(
            len(points_per_shell),
            points_per_shell,
            [[i for i in range(len(points_per_shell))]],
            [1],
        )
        return multishell.optimize(
            len(points_per_shell), points_per_shell, weights, max_iter
        ).tolist()

    @staticmethod
    def generate_gradient_profile(
        bvals,
        bvecs,
        n_b0=1,
        b0_bvec=(0, 0, 0),
        g_type=AcquisitionType.STEJSKAL_TANNER,
        *g_type_args,
        **g_type_kwargs
    ):
        """
        Generate the gradient profile component used to simulate an acquisition
        sequence. Encapsulate the gradient directions, b-values, b0 volumes and
        acquisition sequence type (see AcquisitionType enum).

        Parameters
        ----------
        bvals : list(float)
            List of b-values (must be the same length as
            the gradient vectors list)
        bvecs : list(list(float))
            List of gradient vectors
        n_b0 : int, optional
            Number of b0 volumes to simulate, default : 1
        b0_bvec : list(float)
            Default bvec to assign to all b0 volumes, default : (0, 0, 0)
        g_type : AcquisitionType, optional
            Type of sequence to simulate (see AcquisitionType enum),
            default : AcquisitionType.STEJSKAL_TANNER
        g_type_args :
            Positional arguments needed to initialize the
            sequence type (see .parameters.GradientProfile)
        g_type_kwargs :
            Named arguments needed to initialize the
            sequence type (see .parameters.GradientProfile)

        Returns
        -------
        GradientProfile
            A gradient profile component

        """
        return GradientProfile(
            cat(([0 for _ in range(n_b0)], bvals)) if n_b0 > 0 else bvals,
            cat((array([b0_bvec for _ in range(n_b0)]), bvecs))
            if n_b0 > 0
            else bvecs,
            g_type.value(*g_type_args, **g_type_kwargs),
        )

    @staticmethod
    def generate_artifact_model(*artifact_models):
        """
        Generate the artifact models component from parameters corresponding
        to artifact models generated by the factory.

        Parameters
        ----------
        artifact_models: dict
            Multiple parameters each corresponding to an artifact model

        Returns
        -------
        ArtifactModel
            An artifact models component

        """
        return ArtifactModel(artifact_models)

    @staticmethod
    def generate_noise_model(noise_type, variance):
        """
        Generates a dictionary describing the noise model of
        the simulated acquisition

        Parameters
        ----------
        noise_type : NoiseType
            Type of noise to simulate (see NoiseType enum)
        variance : float
            Variance of the noise distribution

        Returns
        -------
        dict
            A dictionary describing the noise model

        """
        return {
            "descr": "addnoise",
            "noisetype": noise_type,
            "noisevariance": variance,
            "value": True,
        }

    @staticmethod
    def generate_motion_model(
        randomize=False,
        direction_indexes="random",
        rotation=(0, 0, 0),
        translation=(0, 0, 0),
    ):
        """
        Generates a dictionary describing the motion artifact
        model of the simulated acquisition

        Parameters
        ----------
        randomize: bool, optional
            Switch the movement as linear or random, default : False
        direction_indexes : list(int) or str, optional
            Either the indexes of the volumes to affect by motion,
            or "random", default : "random"
        rotation : list(float), optional
            The rotation applied by the motion, default : (0, 0, 0)
        translation : list(float), optional
            The translation applied by the motion, default : (0, 0, 0)

        Returns
        -------
        dict
            A dictionary describing the motion model

        """
        return {
            "descr": "doAddMotion",
            "randomMotion": randomize,
            "motionvolumes": direction_indexes,
            "rotation0": rotation[0],
            "rotation1": rotation[1],
            "rotation2": rotation[2],
            "translation0": translation[0],
            "translation1": translation[1],
            "translation2": translation[2],
            "value": True,
        }

    @staticmethod
    def generate_distortion_model():
        """
        DO NOT USE, STILL NEED TO SEE HOW TO IMPLEMENT

        Returns
        -------
        dict
            A dictionary describing the distortion model

        """
        return {"descr": "doAddDistortions", "value": True}

    @staticmethod
    def generate_eddy_current_model(gradient_strength, gradient_tau=70):
        """
        Generates a dictionary describing the eddy current artifact
        model of the simulated acquisition

        Parameters
        ----------
        gradient_strength : float
            Strength of the eddy current field induced (mT/m)
        gradient_tau : int, optional
            Time constant for the current (millisecond), default : 70

        Returns
        -------
        dict
            A dictionary describing the eddy current model

        """
        return {
            "descr": "addeddycurrents",
            "eddyStrength": gradient_strength,
            "eddyTau": gradient_tau,
            "value": True,
        }

    @staticmethod
    def generate_ghosting_model(k_space_offset):
        """
        Generates a dictionary describing the ghosting artifact
        model of the simulated acquisition

        Parameters
        ----------
        k_space_offset : float
            Offset intensity of the ghost image

        Returns
        -------
        dict
            A dictionary describing the ghosting model

        """
        return {
            "descr": "addghosts",
            "kspaceLineOffset": k_space_offset,
            "value": True,
        }

    @staticmethod
    def generate_signal_spikes_model(number_of_spikes, scale):
        """
        Generates a dictionary describing the signal spike artifact
        model of the simulated acquisition

        Parameters
        ----------
        number_of_spikes : int
            Number of randomly occurring spikes in the signal
        scale : float
            Amplitude of the spikes relative to the largest value in the signal

        Returns
        -------
        dict
            A dictionary describing the signal spike model

        """
        return {
            "descr": "addspikes",
            "spikesnum": number_of_spikes,
            "spikesscale": scale,
            "value": True,
        }

    @staticmethod
    def generate_drift_model(drift_factor):
        """
        Generates a dictionary describing the drift artifact
        model of the simulated acquisition

        Parameters
        ----------
        drift_factor : float
            K-space acquisition drift factor

        Returns
        -------
        dict
            A dictionary describing the drift model

        """
        return {"descr": "doAddDrift", "drift": drift_factor, "value": True}

    @staticmethod
    def generate_aliasing_model(fov_shrink_percent):
        """
        Generates a dictionary describing the aliasing artifact
        model of the simulated acquisition

        Parameters
        ----------
        fov_shrink_percent : float
            Percentage of shrinking of the FOV

        Returns
        -------
        dict
            A dictionary describing the aliasing model

        """
        return {
            "descr": "addaliasing",
            "aliasingfactor": fov_shrink_percent,
            "value": True,
        }

    @staticmethod
    def generate_gibbs_ringing_model(zero_ringing):
        """
        Generates a dictionary describing the gibbs ringing artifact
        model of the simulated acquisition

        Returns
        -------
        dict
            A dictionary describing the gibbs ringing model

        """
        return {
            "descr": "addringing",
            "zeroringing": zero_ringing,
            "value": True,
        }

    @staticmethod
    def generate_fiber_stick_compartment(diffusivity, t1, t2, compartment_type):
        """
        Generates a stick model for a fiber compartment. Can only be
        used for the intra or inter axonal compartment.

        Parameters
        ----------
        diffusivity : float
            Diffusivity of the compartment (mm^2/s)
        t1: int
            T1 relaxation time of the compartment (ms)
        t2 : int
            T2 relaxation time of the compartment (ms)
        compartment_type : CompartmentType
            Simulation compartment to which links the
            model (see CompartmentType enum)

        Returns
        -------
        dict
            A dictionary describing the stick model

        """
        assert compartment_type in [
            SimulationFactory.CompartmentType.INTRA_AXONAL,
            SimulationFactory.CompartmentType.INTER_AXONAL,
        ]
        return {
            "type": "fiber",
            "model": "stick",
            "d": diffusivity,
            "t1": t1,
            "t2": t2,
            "ID": compartment_type.value,
        }

    @staticmethod
    def generate_fiber_tensor_compartment(d1, d2, d3, t1, t2, compartment_type):
        """
        Generates a tensor model for a fiber compartment. Can only be
        used for the intra or inter axonal compartment.

        Parameters
        ----------
        d1 : float
            Axial diffusivity of the compartment (mm^2/s)
        d2 : float
            First radial diffusivity of the compartment (mm^2/s)
        d3 : float
            Second radial diffusivity of the compartment (mm^2/s)
        t1: int
            T1 relaxation time of the compartment (ms)
        t2 : int
            T2 relaxation time of the compartment (ms)
        compartment_type : CompartmentType
            Simulation compartment to which links the
            model (see CompartmentType enum)

        Returns
        -------
        dict
            A dictionary describing the tensor model

        """
        assert compartment_type in [
            SimulationFactory.CompartmentType.INTRA_AXONAL,
            SimulationFactory.CompartmentType.INTER_AXONAL,
        ]
        return {
            "type": "fiber",
            "model": "tensor",
            "d1": d1,
            "d2": d2,
            "d3": d3,
            "t1": t1,
            "t2": t2,
            "ID": compartment_type.value,
        }

    @staticmethod
    def generate_extra_ball_compartment(diffusivity, t1, t2, compartment_type):
        """
        Generates a ball model for a non-fiber compartment. Can only be
        used for the extra axonal compartments.

        Parameters
        ----------
        diffusivity : float
            Diffusivity of the compartment (mm^2/s)
        t1 : int
            T1 relaxation time of the compartment (ms)
        t2 : int
            T2 relaxation time of the compartment (ms)
        compartment_type : CompartmentType
            Simulation compartment to which links the
            model (see CompartmentType enum)

        Returns
        -------
        dict
            A dictionary describing the ball model

        """
        assert compartment_type in [
            SimulationFactory.CompartmentType.EXTRA_AXONAL_1,
            SimulationFactory.CompartmentType.EXTRA_AXONAL_2,
        ]
        return {
            "type": "non-fiber",
            "model": "ball",
            "d": diffusivity,
            "t1": t1,
            "t2": t2,
            "ID": compartment_type.value,
        }
